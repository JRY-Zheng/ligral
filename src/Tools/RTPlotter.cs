using System.Diagnostics;
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using Ligral.Tools.Protocols;
using CurveDictionary = System.Collections.Generic.Dictionary<int, (System.Collections.Generic.List<double>, System.Collections.Generic.List<double>)>;
using Ligral.Simulation;

namespace Ligral.Tools
{
    class RTPlotter : Subscriber, IConfigure
    {
        protected Process PythonProcess;
        protected Dictionary<int, string> FigureName = new Dictionary<int, string>();
        protected Dictionary<int, int> AxesSize = new Dictionary<int, int>();
        protected Dictionary<int, bool> Showed = new Dictionary<int, bool>();
        protected Dictionary<int, bool> Paused = new Dictionary<int, bool>();
        protected CurveDictionary Curves = new CurveDictionary();
        protected bool SaveFigure = false;
        protected Dictionary<double, DateTime> CachedTime;
        public RTPlotter()
        {
            Solver.Starting += Initialise;
            Settings settings = Settings.GetInstance();
            PythonProcess = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = settings.PythonExecutable,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardInput = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true
                }
            };
            try
            {
                PythonProcess.Start();
            }
            catch (System.ComponentModel.Win32Exception)
            {
                throw logger.Error(new LigralException($"{settings.PythonExecutable} is not installed or not callable."));
            }
        }
        protected void Execute(string command)
        {
            PythonProcess.StandardInput.WriteLine(command);
        }
        public override void Unsubscribe()
        {
            if (Publisher.ContainsHooks(this)) Publisher.RemoveHooks(this);
            base.Unsubscribe();
            Execute("exit()");
        }
        protected virtual void Initialise()
        {
            Execute(@"# Auto-generated by Ligral (c) 2020
import matplotlib.pyplot as plt
import numpy as np
");
        }
        protected override bool Receive(FigureProtocol.FigureConfig figureConfig)
        {
            Execute($@"
fig{figureConfig.FigureId}, ax{figureConfig.FigureId} = plt.subplots({figureConfig.RowsCount}, {figureConfig.ColumnsCount}, num='{figureConfig.Title}')
fig{figureConfig.FigureId}.suptitle('{figureConfig.Title}')
");
            if (figureConfig.RowsCount == 1 && figureConfig.ColumnsCount == 1)
            {
                AxesSize[figureConfig.FigureId] = 0;
            }
            else if (figureConfig.RowsCount == 1 || figureConfig.ColumnsCount == 1)
            {
                AxesSize[figureConfig.FigureId] = 1;
            }
            else
            {
                AxesSize[figureConfig.FigureId] = 2;
            }
            FigureName[figureConfig.FigureId] = figureConfig.Title;
            return true;
        }
        protected override bool Receive(FigureProtocol.PlotConfig plotConfig)
        {
            if (AxesSize.ContainsKey(plotConfig.FigureId))
            switch (AxesSize[plotConfig.FigureId])
            {
            case 0:
                Execute($@"
ax{plotConfig.FigureId}.set_xlabel('{plotConfig.XLabel}')
ax{plotConfig.FigureId}.set_ylabel('{plotConfig.YLabel}')
ax{plotConfig.FigureId}.grid()
");
                break;
            case 1:
                int index = plotConfig.RowNO > plotConfig.ColumnNO ? plotConfig.RowNO : plotConfig.ColumnNO;
                Execute($@"
ax = ax{plotConfig.FigureId}[{index}]
ax.set_xlabel({plotConfig.XLabel})
ax.set_ylabel({plotConfig.YLabel})
ax.grid()
");
                break;
            case 2:
                Execute($@"
ax = ax{plotConfig.FigureId}[{plotConfig.RowNO}, {plotConfig.ColumnNO}]
ax.set_xlabel({plotConfig.XLabel})
ax.set_ylabel({plotConfig.YLabel})
ax.grid()
");
                break;
            }
            return true;
        }
        protected override bool Receive(FigureProtocol.DataFile dataFile)
        {
            if (SaveFigure) 
            {
                string fileName = Path.GetFullPath(dataFile.FileName);
                string figName = FigureName[dataFile.FigureId];
                foreach (char invalidChar in Path.GetInvalidFileNameChars())
                {
                    figName = figName.Replace(invalidChar, '_');
                }
                Execute($@"
plt.savefig(r'{Path.GetDirectoryName(fileName)}\{figName}.png')
");
            }
            foreach (var value in Showed.Values)
            {
                if (!value) return true;
            }
            Execute(@"
plt.ioff()
plt.show()
");
            Unsubscribe();
            return true;
        }
        protected override bool Receive(FigureProtocol.Curve curve)
        {
            if (AxesSize.ContainsKey(curve.FigureId))
            switch (AxesSize[curve.FigureId])
            {
            case 0:
                Execute($@"
cv{curve.CurveHandle} = ax{curve.FigureId}.plot([], [])')
xdata{curve.CurveHandle} = cv{curve.CurveHandle}.get_xdata()
ydata{curve.CurveHandle} = cv{curve.CurveHandle}.get_ydata()
");
                break;
            case 1:
                int index = curve.RowNO > curve.ColumnNO ? curve.RowNO : curve.ColumnNO;
                Execute($@"
cv{curve.CurveHandle} = ax = ax{curve.FigureId}[{index}].plot([], [])')
xdata{curve.CurveHandle} = cv{curve.CurveHandle}.get_xdata()
ydata{curve.CurveHandle} = cv{curve.CurveHandle}.get_ydata()
ax.grid()
");
                break;
            case 2:
                Execute($@"
ax = ax{curve.FigureId}[{curve.RowNO}, {curve.ColumnNO}]
cv{curve.CurveHandle} = ax.plot([], [])')
xdata{curve.CurveHandle} = cv{curve.CurveHandle}.get_xdata()
ydata{curve.CurveHandle} = cv{curve.CurveHandle}.get_ydata()
ax.grid()
");
                break;
            }
            Paused[curve.CurveHandle] = false;
            Curves[curve.CurveHandle] = (new List<double>(), new List<double>());
            CachedTime[curve.CurveHandle] = new DateTime();
            return true;
        }

        protected override bool Receive(FigureProtocol.ShowCommand showCommand)
        {
            Execute(@"
plt.ion()
");
            foreach (double curve in CachedTime.Keys)
            {
                CachedTime[curve] = DateTime.Now;
            }
            return true;
        }
        protected override bool Receive(FigureProtocol.Data data)
        {
            if (!Curves.ContainsKey(data.CurveHandle)) return true;
            (var x, var y) = Curves[data.CurveHandle];
            if ((DateTime.Now - CachedTime[data.CurveHandle]).TotalSeconds < 0.5)
            {
                x.Add(data.XValue);
                y.Add(data.YValue);
            }
            else
            {
                Execute($@"
xdata{data.CurveHandle} = np.append(xdata{data.CurveHandle}, [{string.Join(',', x)}])
ydata{data.CurveHandle} = np.append(ydata{data.CurveHandle}, [{string.Join(',', y)}])
cv{data.CurveHandle}.set_data(xdata{data.CurveHandle}, ydata{data.CurveHandle})
ax{data.CurveHandle}.set_xlim((min(xdata{data.CurveHandle}), max(xdata{data.CurveHandle})))
ax{data.CurveHandle}.set_ylim((min(ydata{data.CurveHandle}), max(ydata{data.CurveHandle})))
");
                x.Clear();
                y.Clear();
                CachedTime[data.CurveHandle] = DateTime.Now;
                Paused[data.CurveHandle] = true;
                if (Paused.Values.All(b => b))
                {
                    Execute(@"
plt.pause(0.05)
");
                    foreach (int handle in Paused.Keys)
                    {
                        Paused[handle] = false;
                    }
                }
            }
            return true;
        }
        public void Configure(Dictionary<string, object> dict)
        {
            foreach (string item in dict.Keys)
            {
                object val = dict[item];
                try
                {
                    switch (item)
                    {
                    case "enable":
                        if ((bool) dict[item])
                        {
                            if (!Tools.Publisher.ContainsHooks(this))
                            {
                                Tools.Publisher.AddHooks(this);
                            }
                        }
                        else
                        {
                            if (Tools.Publisher.ContainsHooks(this))
                            {
                                Tools.Publisher.RemoveHooks(this);
                            }
                        }
                        break;
                    case "output_script":
                    case "output_scripts":
                        throw new SettingException(item, val, "Realtime plotter cannot output scripts");
                    case "save_figure":
                    case "save_figures":
                        SaveFigure = (bool) dict[item]; break;
                    default:
                        throw new SettingException(item, val, "Unsupported setting in plotter.");
                    }
                }
                catch (System.InvalidCastException)
                {
                    throw logger.Error(new SettingException(item, val, $"Invalid type {val.GetType()} in plotter"));
                }
            }
        }
    }
}